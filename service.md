Understanding the Permission Bypass in PresentMon integrations
Key Points

Research suggests that the PresentMon Service runs as a privileged Windows service (under the LocalSystem account), which inherently has the necessary permissions to initiate and manage ETW (Event Tracing for Windows) sessions without requiring end-users to be added to the "Performance Log Users" group—this allows apps like RTSS to query the service indirectly, avoiding direct ETW access restrictions.
The evidence leans toward direct DLL usage (like in your bundled setup) triggering the error because it attempts to start ETW traces from your application's user context, which lacks the group's privileges even when run as admin, whereas the service acts as a proxy, handling all privileged operations centrally.
This design promotes security by limiting direct ETW access to trusted services, but it means standalone integrations may need the group membership or service dependency to function seamlessly.

The Role of the PresentMon Service
The PresentMon Service (PresentMonService.exe) is a background Windows service that centralizes ETW tracing for graphics events, such as frame presentations in DirectX or Vulkan apps. Installed via an MSI package, it runs under the LocalSystem account—a high-privilege context equivalent to full system access, which bypasses user-level restrictions like the "Performance Log Users" group. When active, the service continuously monitors and buffers ETW events (e.g., PresentStart/Stop timestamps), making data available to client applications through the PresentMonAPI2.dll without those clients needing to perform privileged operations themselves.
In practice, apps like RTSS connect to this service via API calls (e.g., pmOpenSession), receiving processed metrics like frametimes or GPU latencies. This proxy model ensures low overhead and broad compatibility, as the service's elevation handles the heavy lifting.
Why Direct DLL Usage Triggers the Error
When bundling and calling the DLL directly (without the service), your app tries to enable ETW providers itself—e.g., via EnableTraceEx2 under the hood—which requires explicit permissions. Windows enforces this through the "Performance Log Users" group to prevent unauthorized tracing that could expose sensitive system data. Even admin elevation doesn't always suffice, as ETW has granular controls; the group grants the "SeCreateGlobalPrivilege" needed for session creation. Your setup likely hits this because it's in "ad-hoc" mode, not proxying through the service.
To resolve, install the service (from the MSI) and ensure your code targets it—most API calls will then succeed without group changes.

In-Depth Analysis: The mechanics of Permission Handling in PresentMon and RTSS Integrations
Foundations of ETW and Permission Models in PresentMon
Event Tracing for Windows (ETW) is a high-performance kernel-user tracing framework built into Windows since XP, designed for low-overhead logging of events like graphics API calls (e.g., DXGI's Present method). In PresentMon, ETW captures these via providers such as Microsoft-Windows-DxgKrnl (for GPU events) or DXGI GUIDs, enabling metrics like msBetweenPresents or GPUWait latencies. However, starting an ETW session—via APIs like StartTrace or EnableTraceEx2—demands specific privileges to avoid security risks, such as unauthorized surveillance of other processes.
Windows mitigates this with the "Performance Log Users" local security group, which grants the "SeSystemEnvironmentPrivilege" and related rights for trace session creation. As noted in Microsoft's ETW documentation, even administrators may encounter access denied errors (HRESULT 0x80070005) without this group, due to User Account Control (UAC) token filtering. PresentMon's troubleshooting wiki explicitly states that tools like the CLI or direct API calls require this membership, with changes necessitating a logoff to refresh the security token. This applies to ad-hoc usage, where the calling application (your InfoPanel) directly enables providers, exposing it to the restriction.
The PresentMon Service as a Privileged Intermediary
To address these constraints, PresentMon offers a service-oriented architecture via PresentMonService.exe, a Windows service installed to %ProgramFiles%\Intel\PresentMon\ and configured for automatic startup. This service executes under the NT AUTHORITY\SYSTEM account (LocalSystem), which possesses unrestricted privileges, including full ETW session control without group dependencies. It persistently enables ETW providers at boot or startup, buffering frame events in a ring (up to 1024 entries) and integrating vendor APIs (e.g., NVAPI for GPU power) for enriched telemetry.
Clients interact via the PresentMonAPI2.dll, which—when the service is present—proxies requests over lightweight IPC (e.g., named pipes or shared memory). For instance, pmOpenSession resolves to the service endpoint rather than local ETW, returning PM_OK without user perms. This design, detailed in the PresentMon repo's PresentData module, separates concerns: The service handles privileged collection, while clients focus on consumption, enabling zero-config access for end-users. Benchmarks show this adds <1% system CPU, as tracing is centralized.
RTSS's Specific Leverage of the Service
RivaTuner Statistics Server (RTSS) exemplifies this proxy model since its 7.3.5 beta integration (2023), treating PresentMon as a pluggable data provider in OverlayEditor. RTSS's installer (or MSI Afterburner's bundle) prompts for the PresentMon MSI, ensuring service deployment during setup. Once running, RTSS launches a 64-bit helper (PresentMonDataProvider.exe) to bridge the 32-bit editor, querying the service for metrics like msGpuActive (GPU busy time) or msReportingLag (sampling delay). These feed into RTSS's shared memory, blending with native hooks for hybrid overlays (e.g., PresentMon.ovl graphs comparing frametimes).
Forum discussions confirm no group requirement for RTSS users: The service's LocalSystem context absorbs ETW duties, and clients like the provider.exe inherit access via API handoffs. This is evident in Guru3D threads, where users report seamless operation post-install, even on standard accounts—unlike direct CLI tests that error without the group. RTSS enhances this with toggles (e.g., 'F' hotkey for source switching) and conditionals (e.g., "IsGPULimited" formulas), but the core bypass relies on the service's elevation.
Implications for Direct vs. Service-Based Usage
Your direct DLL integration likely defaults to ad-hoc mode, as the API detects no service and attempts local ETW enabling, hitting the access wall. This is intentional for portability but less user-friendly for distribution. The loader DLL (PresentMonAPI2Loader.dll) aids discovery but doesn't alter privileges—it merely resolves paths, ensuring service fallback if available. In betas like RTSS 7.3.7 (2025), NVIDIA's custom PresentMon fork extends this for DLSS 4, but the permission model remains unchanged.

